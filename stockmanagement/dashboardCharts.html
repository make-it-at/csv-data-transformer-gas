<script>
let originalData = null;

function handleDataFetch(data) {
  console.log('データ取得完了:', data);
  originalData = data;
  populateFilterOptions(data);
  updateDashboard(data);
}

function handleFetchError(error) {
  console.error('データ取得エラー:', error);
  showError('データの取得に失敗しました: ' + error);
}

function populateFilterOptions(data) {
  const stockData = data.stockData;
  
  const accountTypes = [...new Set(stockData.map(s => s.accountType))];
  const industries = [...new Set(stockData.map(s => s.industry))];
  const sensitivities = [...new Set(stockData.map(s => s.sensitivity))];
  const productTypes = [...new Set(stockData.map(s => s.productType))];

  populateSelect('accountType', accountTypes);
  populateSelect('industry', industries);
  populateSelect('sensitivity', sensitivities);
  populateSelect('productType', productTypes);
}

function populateSelect(id, values) {
  const select = document.getElementById(id);
  select.innerHTML = '<option value="all">全て</option>';
  values.sort().forEach(value => {
    if (value) {
      const option = document.createElement('option');
      option.value = value;
      option.textContent = value;
      select.appendChild(option);
    }
  });
}

function getStockColors(stockNames) {
  const baseColors = [
    '#4285F4', '#34A853', '#FBBC05', '#EA4335',
    '#8064A2', '#9E9E9E', '#45B39D', '#DC7633',
    '#5B2C6F', '#CB4335', '#3498DB', '#2ECC71',
    '#F1C40F', '#E74C3C', '#9B59B6', '#1ABC9C',
    '#D35400'
  ];

  const sortedStocks = [...stockNames].sort();
  const colorMap = {};
  sortedStocks.forEach((stock, index) => {
    colorMap[stock] = baseColors[index % baseColors.length];
  });
  
  return colorMap;
}

function createIndustryChart(data) {
  if (!data || !data.stockData.length === 0) return;

  // 銘柄名を収集し、色を割り当て
  const allStockNames = [...new Set(data.stockData.map(s => s.name))];
  const colorMap = getStockColors(allStockNames);

  // 業種ごとの銘柄データを整理
  const stocksByIndustry = new Map();
  data.stockData.forEach(stock => {
    if (!stocksByIndustry.has(stock.industry)) {
      stocksByIndustry.set(stock.industry, new Map());
    }
    stocksByIndustry.get(stock.industry).set(stock.name, stock.value);
  });

  // チャートデータの作成
  const chartData = [['業種', ...allStockNames]];

  // 業種ごとにデータを追加
  Object.entries(data.industryData)
    .sort(([, a], [, b]) => b.value - a.value)
    .forEach(([industry]) => {
      const row = [industry];
      const industryStocks = stocksByIndustry.get(industry) || new Map();
      
      allStockNames.forEach(stockName => {
        const value = industryStocks.get(stockName) || null;
        row.push(value);
      });
      chartData.push(row);
    });

  const dataTable = new google.visualization.arrayToDataTable(chartData);
  const options = {
    title: '業種別評価額（17分類）',
    height: '100%',
    width: '100%',
    isStacked: true,
    legend: { position: 'none' },
    chartArea: { left: '25%', top: '5%', width: '70%', height: '90%' },
    colors: allStockNames.map(name => colorMap[name]),
    hAxis: {
      title: '評価額（円）',
      format: 'short',
      textStyle: { fontSize: 11 }
    },
    vAxis: { textStyle: { fontSize: 11 } },
    bar: { groupWidth: '80%' }
  };

  const chart = new google.visualization.BarChart(
    document.getElementById('industryChart')
  );
  chart.draw(dataTable, options);
  document.getElementById('industryLoading').style.display = 'none';
}

function createYieldChart(data) {
  if (!data || !data.stockData.length === 0) return;

  // 銘柄名を収集し、色を割り当て（業種別と同じ色を使用）
  const allStockNames = [...new Set(data.stockData.map(s => s.name))];
  const colorMap = getStockColors(allStockNames);

  const yieldRanges = [
    { min: 0, max: 1, label: '0-1%' },
    { min: 1, max: 2, label: '1-2%' },
    { min: 2, max: 3, label: '2-3%' },
    { min: 3, max: 4, label: '3-4%' },
    { min: 4, max: 5, label: '4-5%' },
    { min: 5, max: Infinity, label: '5%以上' }
  ];

  // 利回り帯ごとの銘柄データを整理
  const stocksByYield = new Map();
  data.stockData.forEach(stock => {
    if (stock.value > 0) {
      const yield = (stock.dividend / stock.value) * 100;
      const range = yieldRanges.find(r => yield >= r.min && yield < r.max);
      if (range) {
        if (!stocksByYield.has(range.label)) {
          stocksByYield.set(range.label, new Map());
        }
        stocksByYield.get(range.label).set(stock.name, stock.value);
      }
    }
  });

  // チャートデータの作成
  const chartData = [['利回り帯', ...allStockNames]];
  yieldRanges.forEach(range => {
    const yieldStocks = stocksByYield.get(range.label);
    if (yieldStocks && yieldStocks.size > 0) {
      const row = [range.label];
      allStockNames.forEach(stockName => {
        const value = yieldStocks.get(stockName) || null;
        row.push(value);
      });
      chartData.push(row);
    }
  });

  const dataTable = new google.visualization.arrayToDataTable(chartData);
  const options = {
    title: '利回り帯別評価額',
    height: '100%',
    width: '100%',
    isStacked: true,
    legend: { position: 'none' },
    chartArea: { left: '15%', top: '5%', width: '80%', height: '90%' },
    colors: allStockNames.map(name => colorMap[name]),
    vAxis: { 
      title: '評価額（円）',
      format: 'short',
      textStyle: { fontSize: 11 }
    },
    hAxis: { textStyle: { fontSize: 11 } },
    bar: { groupWidth: '80%' }
  };

  const chart = new google.visualization.ColumnChart(
    document.getElementById('yieldChart')
  );
  chart.draw(dataTable, options);
  document.getElementById('yieldLoading').style.display = 'none';
}

// 以下の関数は変更なし
function applyFilters() {
  const filters = {
    accountType: document.getElementById('accountType').value,
    industry: document.getElementById('industry').value,
    sensitivity: document.getElementById('sensitivity').value,
    productType: document.getElementById('productType').value
  };

  const filteredData = filterData(filters);
  updateDashboard(filteredData);
}

function filterData(filters) {
  if (!originalData) return null;

  const filteredStocks = originalData.stockData.filter(stock => {
    return (filters.accountType === 'all' || stock.accountType === filters.accountType) &&
           (filters.industry === 'all' || stock.industry === filters.industry) &&
           (filters.sensitivity === 'all' || stock.sensitivity === filters.sensitivity) &&
           (filters.productType === 'all' || stock.productType === filters.productType);
  });

  return recalculateData(filteredStocks);
}

function recalculateData(filteredStocks) {
  const newData = {
    stockData: filteredStocks,
    industryData: {},
    totalValue: 0,
    totalDividend: 0
  };

  filteredStocks.forEach(stock => {
    if (!newData.industryData[stock.industry]) {
      newData.industryData[stock.industry] = { value: 0, stocks: {} };
    }
    newData.industryData[stock.industry].value += stock.value;
    newData.industryData[stock.industry].stocks[stock.name] = stock.value;
    
    newData.totalValue += stock.value;
    newData.totalDividend += stock.dividend;
  });

  newData.bookYield = newData.totalValue > 0 ? 
    (newData.totalDividend / newData.totalValue) * 100 : 0;

  return newData;
}

function updateDashboard(data) {
  if (!data) return;
  updateSummary(data);
  createIndustryChart(data);
  createYieldChart(data);
}

function updateSummary(data) {
  document.getElementById('totalValue').innerText = formatCurrency(data.totalValue);
  document.getElementById('totalDividend').innerText = formatCurrency(data.totalDividend);
  document.getElementById('bookYield').innerText = formatPercentage(data.bookYield);
}

function formatCurrency(value) {
  return new Intl.NumberFormat('ja-JP', {
    style: 'currency',
    currency: 'JPY',
    maximumFractionDigits: 0
  }).format(value);
}

function formatPercentage(value) {
  return new Intl.NumberFormat('ja-JP', {
    style: 'percent',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(value / 100);
}

function resetFilters() {
  ['accountType', 'industry', 'sensitivity', 'productType'].forEach(id => {
    document.getElementById(id).value = 'all';
  });
  if (originalData) {
    updateDashboard(originalData);
  }
}

function showError(message) {
  document.querySelectorAll('.loading').forEach(el => {
    el.style.display = 'block';
    el.innerText = message;
  });
}

window.addEventListener('resize', () => {
  if (originalData) {
    updateDashboard(originalData);
  }
});
</script>